// c++에 새로 생긴 연산자
/*
1. 범위 지정 연산자(scope resolution operator)
2. 멤버 포인터 연산자(pointer-to-member operator)
3. typeid 연산자
*/ 


/*
c++에서 가장 운선순위가 높은 연산자는 바로 범위 지정 연산자이다.
문법 :
	1. ::식별자
	2. 클래스이름::식별자
	3. 네임스페이스::식별자
	4. 열거체::식별자
*/



/*
멤버 포인터 연산자(pointer-to-member operator)
C++에서는 멤버 포인터 연산자를 사용하여 클래스의 멤버를 가리키는 포인터를 정의할 수 있습니다.

이러한 멤버 포인터 연산자는 다음과 같이 두 가지 형태가 있습니다.

 

1. 왼쪽의 피연산자가 클래스 타입의 객체인 경우 : .*

2. 왼쪽의 피연산자가 클래스 타입의 객체를 가리키는 포인터인 경우 : ->*

 

C++에서 멤버 포인터 연산자를 사용하기 위한 문법은 다음과 같습니다.

문법
1. 클래스타입의객체.*멤버이름

2. 클래스타입객체의포인터->*멤버이름 
*/


/*
typeid 연산자
C++에서는 typeid 연산자를 사용하여 객체의 타입에 관한 정보를 확인할 수 있습니다.

이러한 typeid 연산자는 런타임에 객체의 타입을 결정하는 데 사용합니다.

또한, 템플릿에서 템플릿 매개변수의 타입을 결정할 때도 사용합니다.

 

문법
typeid(표현식)
*/





#include<iostream>


/*
auto func(auto x, auto y){
	
	return x + y;
}
*/
// 위와 같은 선언은 할 수 없다.
// auto 키워드는 어디까지나 변수 선언 시의 타입 추론일 뿐이지, 파이썬처럼 자유롭게 쓸 수 없다.
// 함수의 인풋과 아웃풋은 엄격히 정해져야 하기 때문에 auto를 사용 시 컴파일되지 않는다. 

int main(){
	auto x = 10;
	auto y = 1.5;
	// auto 키워드는 선언 시 초기화해줘야 한다. ~ 안 쓰는 게 권장된다.
		
	
	return 0;
}









